# Document E: Vector Store Role

**Phase 0 Exploration Document**
**Date**: 2026-01-07
**Scope**: What gets embedded, when, how queried, what is returned

---

## Overview

FiskAI uses **pgvector** (PostgreSQL extension) for semantic search capabilities. All embeddings are 768-dimensional vectors generated by the **nomic-embed-text** model via Ollama.

---

## Vector-Enabled Tables

| Table            | Column    | Dimension | Index               | Purpose                      |
| ---------------- | --------- | --------- | ------------------- | ---------------------------- |
| Evidence         | embedding | 768       | IVFFlat (100 lists) | Semantic duplicate detection |
| SourcePointer    | embedding | 768       | IVFFlat (100 lists) | Regulatory content search    |
| ConceptEmbedding | embedding | 768       | IVFFlat (10 lists)  | Query-to-concept matching    |

---

## Embedding Generation

### Configuration

**Environment Variables**:

```bash
OLLAMA_EMBED_ENDPOINT=http://100.89.2.111:11434
OLLAMA_EMBED_MODEL=nomic-embed-text
OLLAMA_EMBED_API_KEY=local
OLLAMA_EMBED_DIMS=768
```

### Core Embedder

**Location**: `src/lib/article-agent/verification/embedder.ts`

```typescript
export async function embedText(text: string): Promise<number[]> {
  const config = getEmbedConfig()

  const response = await fetch(`${config.endpoint}/api/embed`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      model: config.model,
      input: text,
    }),
  })

  const data = await response.json()
  return data.embeddings[0] // 768-dim vector
}

export async function embedBatch(texts: string[]): Promise<number[][]> {
  // Efficient batch embedding
}
```

---

## 1. Evidence Embeddings

### What Gets Embedded

**Source**: `Evidence.rawContent` (max 4000 characters)

**Processing**: HTML normalization via `normalizeHtmlContent()`

```typescript
async function generateEvidenceEmbedding(evidenceId: string): Promise<number[]> {
  const evidence = await dbReg.evidence.findUnique({ where: { id: evidenceId } })

  // Truncate to MAX_EMBEDDING_LENGTH
  const text = normalizeHtmlContent(evidence.rawContent).slice(0, 4000)

  const embedding = await embedText(text)

  await prisma.$executeRaw`
    UPDATE "regulatory"."Evidence"
    SET "embedding" = ${JSON.stringify(embedding)}::vector
    WHERE "id" = ${evidenceId}
  `

  return embedding
}
```

### When Generated

**Trigger**: Evidence creation in Sentinel
**Worker**: `workers/evidence-embedding.worker.ts`
**Queue**: `evidenceEmbeddingQueue` (rate: 5/min)

**Status Tracking**:

```
PENDING → PROCESSING → COMPLETED | FAILED
```

### How Queried

**Purpose**: Semantic duplicate detection

```sql
SELECT
  "id",
  "url",
  "contentHash",
  "sourceId",
  1 - ("embedding" <=> $1::vector) as similarity
FROM "regulatory"."Evidence"
WHERE "id" != ${evidenceId}
  AND "embedding" IS NOT NULL
  AND "deletedAt" IS NULL
  AND 1 - ("embedding" <=> $1::vector) >= 0.85
ORDER BY "embedding" <=> $1::vector ASC
LIMIT 10
```

**Threshold**: 0.85 similarity (high threshold for duplicate detection)

### What Is Returned

```typescript
interface SimilarEvidence {
  id: string
  url: string
  contentHash: string
  sourceId: string
  similarity: number // 0.85-1.0
}
```

---

## 2. SourcePointer Embeddings

### What Gets Embedded

**Source**: `exactQuote + contextBefore + contextAfter`

```typescript
function buildEmbeddingText(pointer: SourcePointer): string {
  return [pointer.contextBefore, pointer.exactQuote, pointer.contextAfter].filter(Boolean).join(" ")
}
```

### When Generated

**Trigger**: After extraction validation passes
**Location**: `utils/rtl-embedder.ts`
**Batch**: `generatePointerEmbeddingsBatch(pointerIds)`

### How Queried

**Purpose**: Semantic search for regulatory content

**Location**: `src/lib/regulatory-truth/retrieval/semantic-search.ts`

```sql
SELECT
  sp."id" as "pointerId",
  1 - (sp."embedding" <=> $1::vector) as similarity,
  sp."exactQuote",
  sp."contextBefore",
  sp."contextAfter",
  sp."domain",
  sp."valueType",
  sp."extractedValue",
  sp."confidence",
  sp."articleNumber",
  sp."lawReference",
  sp."evidenceId",
  e."url" as "evidenceUrl",
  s."name" as "sourceName",
  s."url" as "sourceUrl"
FROM "SourcePointer" sp
INNER JOIN "Evidence" e ON e."id" = sp."evidenceId"
INNER JOIN "RegulatorySource" s ON s."id" = e."sourceId"
WHERE
  sp."domain" = $2  -- Optional domain filter
  AND sp."confidence" >= $3  -- Min confidence (default 0.7)
  AND sp."deletedAt" IS NULL
  AND sp."embedding" IS NOT NULL
ORDER BY sp."embedding" <=> $1::vector ASC
LIMIT $4
```

**Threshold**: 0.7 similarity (default)

### What Is Returned

```typescript
interface SemanticSearchResult {
  pointerId: string
  similarity: number
  exactQuote: string
  contextBefore: string | null
  contextAfter: string | null
  domain: string
  valueType: string
  extractedValue: string
  confidence: number
  articleNumber: string | null
  lawReference: string | null
  evidenceId: string
  evidenceUrl: string
  sourceName: string
  sourceUrl: string
}
```

---

## 3. Concept Embeddings

### What Gets Embedded

**Source**: `Concept.nameHr + Concept.aliases`

```typescript
const embeddingText = [concept.nameHr, ...concept.aliases].join(" ")
```

### When Generated

**Trigger**: Manual script execution
**Location**: `src/lib/assistant/scripts/generate-concept-embeddings.ts`
**Command**: `npx tsx src/lib/assistant/scripts/generate-concept-embeddings.ts`

### How Queried

**Purpose**: Query-to-concept matching in AI Assistant

**Location**: `src/lib/assistant/query-engine/semantic-search.ts`

```sql
SELECT
  c.id as "conceptId",
  c.slug,
  c."nameHr",
  1 - (ce.embedding <=> ${queryVector}::vector) as similarity
FROM "Concept" c
INNER JOIN "ConceptEmbedding" ce ON ce."conceptId" = c.id
WHERE ce.embedding IS NOT NULL
ORDER BY ce.embedding <=> ${queryVector}::vector
LIMIT ${topK}
```

**Threshold**: 0.3 similarity (lower threshold for discovery)

### What Is Returned

```typescript
interface ConceptMatch {
  conceptId: string
  slug: string
  nameHr: string
  similarity: number
}
```

---

## Hybrid Search

### Concept Matching

**Location**: `src/lib/assistant/query-engine/semantic-search.ts`

```typescript
export async function hybridSearch(
  query: string,
  keywordMatches: Array<{ slug: string; score: number }>,
  options?: HybridSearchOptions
): Promise<SemanticMatch[]> {
  const semanticWeight = options?.semanticWeight ?? 0.7
  const keywordWeight = options?.keywordWeight ?? 0.3

  // 1. Generate query embedding
  const queryEmbedding = await embedText(query)

  // 2. Semantic search
  const semanticResults = await semanticSearch(query, queryEmbedding)

  // 3. Combine scores
  const combined = mergeResults(semanticResults, keywordMatches, semanticWeight, keywordWeight)

  return combined
}
```

### Score Combination

```typescript
finalScore = semanticSimilarity * 0.7 + keywordScore * 0.3
```

---

## Index Configuration

### IVFFlat Index

**Type**: Inverted File Flat
**Operator**: `vector_cosine_ops` (cosine similarity)

```sql
-- Evidence (100 lists for larger dataset)
CREATE INDEX evidence_embedding_idx ON "Evidence"
  USING ivfflat ("embedding" vector_cosine_ops)
  WITH (lists = 100);

-- SourcePointer (100 lists)
CREATE INDEX source_pointer_embedding_idx ON "SourcePointer"
  USING ivfflat ("embedding" vector_cosine_ops)
  WITH (lists = 100);

-- ConceptEmbedding (10 lists for smaller dataset)
CREATE INDEX "ConceptEmbedding_embedding_idx" ON "ConceptEmbedding"
  USING ivfflat (embedding vector_cosine_ops)
  WITH (lists = 10);
```

### Why IVFFlat?

- **Approximate nearest neighbor** search
- **Better performance** for large datasets (vs exact search)
- **Trade-off**: Slight accuracy reduction for significant speed improvement
- **Lists parameter**: Higher = more accuracy, slower; Lower = faster, less accurate

---

## Vector Operations

### Distance Operators

| Operator | Description     | Usage                            |
| -------- | --------------- | -------------------------------- |
| `<=>`    | Cosine distance | Primary (smaller = more similar) |
| `<->`    | L2 (Euclidean)  | Alternative                      |
| `<#>`    | Inner product   | For normalized vectors           |

### Similarity Calculation

```sql
-- Cosine similarity = 1 - cosine distance
SELECT 1 - (embedding <=> query_vector::vector) as similarity
```

### Vector Format

**Storage**: PostgreSQL array as string
**Format**: `[0.1, 0.2, ..., 0.768]`

```typescript
// Insert/Update
await prisma.$executeRaw`
  UPDATE "SourcePointer"
  SET "embedding" = ${JSON.stringify(embedding)}::vector
  WHERE "id" = ${pointerId}
`

// Query
const results = await prisma.$queryRawUnsafe<Result[]>(
  `SELECT * FROM "SourcePointer" ORDER BY embedding <=> $1::vector`,
  JSON.stringify(queryEmbedding)
)
```

---

## Embedding Workers

### Evidence Embedding Worker

**Location**: `workers/evidence-embedding.worker.ts`

```typescript
async function processEvidenceEmbeddingJob(job: Job<EvidenceEmbeddingJobData>): Promise<JobResult> {
  const { evidenceId } = job.data

  // Update status: PROCESSING
  await dbReg.evidence.update({
    where: { id: evidenceId },
    data: {
      embeddingStatus: "PROCESSING",
      embeddingAttempts: { increment: 1 },
      embeddingUpdatedAt: new Date(),
    },
  })

  try {
    await generateEvidenceEmbedding(evidenceId)

    // Update status: COMPLETED
    await dbReg.evidence.update({
      where: { id: evidenceId },
      data: {
        embeddingStatus: "COMPLETED",
        embeddingUpdatedAt: new Date(),
      },
    })
  } catch (error) {
    // Update status: FAILED
    await dbReg.evidence.update({
      where: { id: evidenceId },
      data: {
        embeddingStatus: "FAILED",
        embeddingError: error.message,
        embeddingUpdatedAt: new Date(),
      },
    })
  }
}
```

### Queue Configuration

```typescript
export const evidenceEmbeddingQueue = createQueue("evidence-embedding", {
  max: 5, // 5 jobs per
  duration: 60000, // 60 seconds
})

// Worker: 2 concurrent jobs
const worker = createWorker("evidence-embedding", processEvidenceEmbeddingJob, { concurrency: 2 })
```

---

## Backfill Scripts

### SourcePointer Backfill

**Location**: `src/lib/regulatory-truth/scripts/backfill-embeddings.ts`

```bash
npx tsx src/lib/regulatory-truth/scripts/backfill-embeddings.ts \
  --batch-size 50 \
  --dry-run
```

### Evidence Backfill

**Location**: `scripts/backfill-evidence-embeddings.ts`

```bash
npx tsx scripts/backfill-evidence-embeddings.ts --dry-run
```

---

## Query Flow Example

### User Query → Semantic Search → Answer

```
User: "Koliki je prag za paušalni obrt?"
                │
                ▼
        embedText(query)
                │
                ▼
        768-dim vector
                │
        ┌───────┴────────┐
        ▼                ▼
  ConceptEmbedding    SourcePointer
  (concept match)     (content search)
        │                │
        ▼                ▼
  slug: "pausalni-    exactQuote: "Prag
  revenue-threshold"  prihoda za paušalni
                      obrt je 40.000 EUR"
        │                │
        └───────┬────────┘
                ▼
        RegulatoryRule
        (via conceptSlug or sourcePointers)
                │
                ▼
        AssistantResponse
```

---

## Performance Metrics

### Embedding Generation

| Operation              | Avg Time | Batch Size   |
| ---------------------- | -------- | ------------ |
| Single embedding       | ~50ms    | 1            |
| Batch embedding        | ~500ms   | 50           |
| Full Evidence backfill | ~10 min  | 1000 records |

### Query Performance

| Query Type           | Avg Time | Records       |
| -------------------- | -------- | ------------- |
| Concept search       | <10ms    | ~100 concepts |
| SourcePointer search | <50ms    | ~10k pointers |
| Evidence similarity  | <100ms   | ~5k evidence  |

---

## UNKNOWN Items

1. **HNSW Index**: Not implemented (IVFFlat only)
2. **Embedding Versioning**: No tracking of model changes
3. **Stale Embedding Detection**: No automatic re-embedding when content changes
4. **Cross-Table Similarity**: No unified embedding search across tables
5. **Embedding Cache**: No caching layer for frequent queries
6. **Dimension Reduction**: No PCA or other dimension reduction

---

## References

- Embedder: `src/lib/article-agent/verification/embedder.ts`
- Evidence Embedder: `src/lib/regulatory-truth/utils/evidence-embedder.ts`
- RTL Embedder: `src/lib/regulatory-truth/utils/rtl-embedder.ts`
- Semantic Search: `src/lib/regulatory-truth/retrieval/semantic-search.ts`
- Assistant Search: `src/lib/assistant/query-engine/semantic-search.ts`
- Embedding Worker: `src/lib/regulatory-truth/workers/evidence-embedding.worker.ts`
- Migrations: `prisma/migrations/20251229*/migration.sql`
