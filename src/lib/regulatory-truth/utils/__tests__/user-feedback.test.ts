// src/lib/regulatory-truth/utils/__tests__/user-feedback.test.ts
//
// Unit tests for user feedback collection and analysis
// Task 4.1: RTL Autonomy - User Feedback Loop
//
// Tests feedback recording, privacy safeguards, retention policy, and negative feedback detection.
// All tests are unit tests - no database dependencies.

import { describe, it, expect, beforeEach, vi, afterEach } from "vitest"
import {
  Sentiment,
  ReasonCode,
  type FeedbackInput,
  type FeedbackRecord,
  type RuleWithNegativeFeedback,
  createFeedbackRecord,
  hashUserIdWithConsent,
  isRetentionExpired,
  getRetentionCutoffDate,
  calculateNegativeFeedbackPercentage,
  filterRulesWithHighNegativeFeedback,
  RETENTION_MONTHS,
  NEGATIVE_FEEDBACK_THRESHOLD,
} from "../user-feedback"

describe("Sentiment enum", () => {
  it("should have positive and negative values", () => {
    expect(Sentiment.POSITIVE).toBe("positive")
    expect(Sentiment.NEGATIVE).toBe("negative")
  })
})

describe("ReasonCode enum", () => {
  it("should have all expected reason codes", () => {
    expect(ReasonCode.INACCURATE).toBe("inaccurate")
    expect(ReasonCode.OUTDATED).toBe("outdated")
    expect(ReasonCode.UNCLEAR).toBe("unclear")
    expect(ReasonCode.OTHER).toBe("other")
  })
})

describe("createFeedbackRecord", () => {
  const baseInput: FeedbackInput = {
    ruleId: "rule-123",
    sentiment: Sentiment.POSITIVE,
    appVersion: "1.0.0",
  }

  it("should create minimal feedback record without PII", () => {
    const record = createFeedbackRecord(baseInput)

    expect(record.ruleId).toBe("rule-123")
    expect(record.sentiment).toBe("positive")
    expect(record.appVersion).toBe("1.0.0")
    expect(record.createdAt).toBeInstanceOf(Date)
    // Critically: no userId or sessionId
    expect(record).not.toHaveProperty("userId")
    expect(record).not.toHaveProperty("sessionId")
    expect(record).not.toHaveProperty("ipAddress")
  })

  it("should include optional reasonCode when provided", () => {
    const input: FeedbackInput = {
      ...baseInput,
      sentiment: Sentiment.NEGATIVE,
      reasonCode: ReasonCode.INACCURATE,
    }

    const record = createFeedbackRecord(input)

    expect(record.reasonCode).toBe("inaccurate")
  })

  it("should NOT include anonymousUserHash when no consent", () => {
    const input: FeedbackInput = {
      ...baseInput,
      userId: "user-abc",
      hasConsent: false,
    }

    const record = createFeedbackRecord(input)

    expect(record.anonymousUserHash).toBeUndefined()
  })

  it("should include anonymousUserHash ONLY when user consents", () => {
    const input: FeedbackInput = {
      ...baseInput,
      userId: "user-abc",
      hasConsent: true,
    }

    const record = createFeedbackRecord(input)

    // Should have hashed ID
    expect(record.anonymousUserHash).toBeDefined()
    expect(record.anonymousUserHash).toHaveLength(64) // SHA-256 hex
    // Should NOT have original userId
    expect(record).not.toHaveProperty("userId")
  })

  it("should NOT include anonymousUserHash when userId not provided", () => {
    const input: FeedbackInput = {
      ...baseInput,
      hasConsent: true, // Consent given but no userId
    }

    const record = createFeedbackRecord(input)

    expect(record.anonymousUserHash).toBeUndefined()
  })

  it("should generate unique id for each record", () => {
    const record1 = createFeedbackRecord(baseInput)
    const record2 = createFeedbackRecord(baseInput)

    // IDs should be unique (or at least records should be distinguishable)
    // In practice, IDs are generated by the database, so we just check the structure
    expect(record1).toHaveProperty("createdAt")
    expect(record2).toHaveProperty("createdAt")
  })

  it("should capture createdAt timestamp", () => {
    const before = new Date()
    const record = createFeedbackRecord(baseInput)
    const after = new Date()

    expect(record.createdAt.getTime()).toBeGreaterThanOrEqual(before.getTime())
    expect(record.createdAt.getTime()).toBeLessThanOrEqual(after.getTime())
  })
})

describe("hashUserIdWithConsent", () => {
  it("should return undefined when no consent", () => {
    const result = hashUserIdWithConsent("user-123", false)
    expect(result).toBeUndefined()
  })

  it("should return undefined when userId is undefined", () => {
    const result = hashUserIdWithConsent(undefined, true)
    expect(result).toBeUndefined()
  })

  it("should return undefined when userId is empty", () => {
    const result = hashUserIdWithConsent("", true)
    expect(result).toBeUndefined()
  })

  it("should return SHA-256 hash when consent is given", () => {
    const result = hashUserIdWithConsent("user-123", true)

    expect(result).toBeDefined()
    expect(result).toHaveLength(64) // SHA-256 produces 64 hex characters
  })

  it("should produce different hashes for different users", () => {
    const hash1 = hashUserIdWithConsent("user-123", true)
    const hash2 = hashUserIdWithConsent("user-456", true)

    expect(hash1).not.toBe(hash2)
  })

  it("should produce same hash for same user (deterministic)", () => {
    const hash1 = hashUserIdWithConsent("user-123", true)
    const hash2 = hashUserIdWithConsent("user-123", true)

    expect(hash1).toBe(hash2)
  })

  it("should use salted hash (not just plain SHA-256 of userId)", () => {
    const hash = hashUserIdWithConsent("user-123", true)
    // The hash should not be the plain SHA-256 of "user-123"
    // This ensures we're using a salt
    const plainSha256 = "65e84be33532fb784c48129675f9eff3a682b27168c0ea744b2cf58ee02337c5"
    expect(hash).not.toBe(plainSha256)
  })
})

describe("Retention policy", () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })

  afterEach(() => {
    vi.useRealTimers()
  })

  it("should define 12-month retention period", () => {
    expect(RETENTION_MONTHS).toBe(12)
  })

  describe("getRetentionCutoffDate", () => {
    it("should return date 12 months ago by default", () => {
      const now = new Date("2024-06-15T12:00:00Z")
      vi.setSystemTime(now)

      const cutoff = getRetentionCutoffDate()

      // Should be approximately 12 months ago
      expect(cutoff.getFullYear()).toBe(2023)
      expect(cutoff.getMonth()).toBe(5) // June (0-indexed)
    })

    it("should accept custom retention months", () => {
      const now = new Date("2024-06-15T12:00:00Z")
      vi.setSystemTime(now)

      const cutoff = getRetentionCutoffDate(6)

      // Should be 6 months ago
      expect(cutoff.getFullYear()).toBe(2023)
      expect(cutoff.getMonth()).toBe(11) // December (0-indexed)
    })

    it("should handle year boundary correctly", () => {
      const now = new Date("2024-03-15T12:00:00Z")
      vi.setSystemTime(now)

      const cutoff = getRetentionCutoffDate(12)

      // 12 months before March 2024 = March 2023
      expect(cutoff.getFullYear()).toBe(2023)
      expect(cutoff.getMonth()).toBe(2) // March
    })
  })

  describe("isRetentionExpired", () => {
    it("should return true for records older than retention period", () => {
      const now = new Date("2024-06-15T12:00:00Z")
      vi.setSystemTime(now)

      const oldRecord: FeedbackRecord = {
        ruleId: "rule-1",
        sentiment: "positive",
        appVersion: "1.0.0",
        createdAt: new Date("2023-01-01T00:00:00Z"), // More than 12 months ago
      }

      expect(isRetentionExpired(oldRecord)).toBe(true)
    })

    it("should return false for recent records", () => {
      const now = new Date("2024-06-15T12:00:00Z")
      vi.setSystemTime(now)

      const recentRecord: FeedbackRecord = {
        ruleId: "rule-1",
        sentiment: "positive",
        appVersion: "1.0.0",
        createdAt: new Date("2024-01-01T00:00:00Z"), // Less than 12 months ago
      }

      expect(isRetentionExpired(recentRecord)).toBe(false)
    })

    it("should return false for records exactly at retention boundary", () => {
      const now = new Date("2024-06-15T12:00:00Z")
      vi.setSystemTime(now)

      const boundaryRecord: FeedbackRecord = {
        ruleId: "rule-1",
        sentiment: "positive",
        appVersion: "1.0.0",
        createdAt: new Date("2023-06-15T12:00:00Z"), // Exactly 12 months ago
      }

      // At boundary should not be expired (use >= not >)
      expect(isRetentionExpired(boundaryRecord)).toBe(false)
    })

    it("should accept custom retention months", () => {
      const now = new Date("2024-06-15T12:00:00Z")
      vi.setSystemTime(now)

      const record: FeedbackRecord = {
        ruleId: "rule-1",
        sentiment: "positive",
        appVersion: "1.0.0",
        createdAt: new Date("2024-01-01T00:00:00Z"), // 5.5 months ago
      }

      expect(isRetentionExpired(record, 6)).toBe(false) // Not expired at 6 months
      expect(isRetentionExpired(record, 3)).toBe(true) // Expired at 3 months
    })
  })
})

describe("Negative feedback analysis", () => {
  describe("calculateNegativeFeedbackPercentage", () => {
    it("should calculate correct percentage", () => {
      const feedbackCounts = {
        positive: 7,
        negative: 3,
      }

      const percentage = calculateNegativeFeedbackPercentage(feedbackCounts)

      expect(percentage).toBe(0.3) // 30%
    })

    it("should return 0 when no negative feedback", () => {
      const feedbackCounts = {
        positive: 10,
        negative: 0,
      }

      const percentage = calculateNegativeFeedbackPercentage(feedbackCounts)

      expect(percentage).toBe(0)
    })

    it("should return 1 when all feedback is negative", () => {
      const feedbackCounts = {
        positive: 0,
        negative: 10,
      }

      const percentage = calculateNegativeFeedbackPercentage(feedbackCounts)

      expect(percentage).toBe(1)
    })

    it("should return 0 when no feedback at all", () => {
      const feedbackCounts = {
        positive: 0,
        negative: 0,
      }

      const percentage = calculateNegativeFeedbackPercentage(feedbackCounts)

      expect(percentage).toBe(0)
    })

    it("should handle fractional percentages", () => {
      const feedbackCounts = {
        positive: 2,
        negative: 1,
      }

      const percentage = calculateNegativeFeedbackPercentage(feedbackCounts)

      expect(percentage).toBeCloseTo(0.333, 2) // ~33.3%
    })
  })

  describe("filterRulesWithHighNegativeFeedback", () => {
    const ruleStats: RuleWithNegativeFeedback[] = [
      { ruleId: "rule-1", negativePercent: 0.1, totalFeedback: 100 }, // 10% - OK
      { ruleId: "rule-2", negativePercent: 0.35, totalFeedback: 50 }, // 35% - FLAGGED
      { ruleId: "rule-3", negativePercent: 0.5, totalFeedback: 20 }, // 50% - FLAGGED
      { ruleId: "rule-4", negativePercent: 0.25, totalFeedback: 80 }, // 25% - OK
      { ruleId: "rule-5", negativePercent: 0.31, totalFeedback: 30 }, // 31% - FLAGGED (just over)
    ]

    it("should define 30% negative feedback threshold", () => {
      expect(NEGATIVE_FEEDBACK_THRESHOLD).toBe(0.3)
    })

    it("should filter rules exceeding 30% threshold", () => {
      const flagged = filterRulesWithHighNegativeFeedback(ruleStats)

      expect(flagged).toHaveLength(3)
      expect(flagged.map((r) => r.ruleId)).toContain("rule-2")
      expect(flagged.map((r) => r.ruleId)).toContain("rule-3")
      expect(flagged.map((r) => r.ruleId)).toContain("rule-5")
    })

    it("should NOT include rules at exactly 30%", () => {
      const statsWithBoundary: RuleWithNegativeFeedback[] = [
        { ruleId: "rule-exact", negativePercent: 0.3, totalFeedback: 100 }, // Exactly 30%
      ]

      const flagged = filterRulesWithHighNegativeFeedback(statsWithBoundary)

      expect(flagged).toHaveLength(0) // 30% exactly is not > 30%
    })

    it("should accept custom threshold", () => {
      const flagged = filterRulesWithHighNegativeFeedback(ruleStats, 0.4)

      expect(flagged).toHaveLength(1) // Only rule-3 exceeds 40%
      expect(flagged[0].ruleId).toBe("rule-3")
    })

    it("should return empty array when no rules exceed threshold", () => {
      const goodStats: RuleWithNegativeFeedback[] = [
        { ruleId: "rule-1", negativePercent: 0.1, totalFeedback: 100 },
        { ruleId: "rule-2", negativePercent: 0.2, totalFeedback: 50 },
      ]

      const flagged = filterRulesWithHighNegativeFeedback(goodStats)

      expect(flagged).toHaveLength(0)
    })

    it("should sort results by negative percentage descending", () => {
      const flagged = filterRulesWithHighNegativeFeedback(ruleStats)

      // Should be sorted: rule-3 (50%), rule-2 (35%), rule-5 (31%)
      expect(flagged[0].ruleId).toBe("rule-3")
      expect(flagged[1].ruleId).toBe("rule-2")
      expect(flagged[2].ruleId).toBe("rule-5")
    })
  })
})

describe("Privacy safeguards documentation", () => {
  // These tests document expected privacy behavior

  describe("Minimal data collection", () => {
    it("should store only: ruleId, sentiment, timestamp, appVersion, optional reasonCode", () => {
      const input: FeedbackInput = {
        ruleId: "rule-123",
        sentiment: Sentiment.NEGATIVE,
        appVersion: "2.0.0",
        reasonCode: ReasonCode.OUTDATED,
      }

      const record = createFeedbackRecord(input)

      // Required fields
      expect(record).toHaveProperty("ruleId")
      expect(record).toHaveProperty("sentiment")
      expect(record).toHaveProperty("appVersion")
      expect(record).toHaveProperty("createdAt")

      // Optional fields
      expect(record).toHaveProperty("reasonCode")

      // FORBIDDEN fields (should never be stored)
      expect(record).not.toHaveProperty("userId")
      expect(record).not.toHaveProperty("sessionId")
      expect(record).not.toHaveProperty("ipAddress")
      expect(record).not.toHaveProperty("email")
      expect(record).not.toHaveProperty("userAgent")
    })
  })

  describe("No PII by default", () => {
    it("should not store any user identifiers without explicit consent", () => {
      const input: FeedbackInput = {
        ruleId: "rule-123",
        sentiment: Sentiment.POSITIVE,
        appVersion: "1.0.0",
        userId: "user-secret-id", // User ID provided but no consent
      }

      const record = createFeedbackRecord(input)

      // Even with userId in input, should not appear in record
      expect(record.anonymousUserHash).toBeUndefined()
      expect(Object.values(record)).not.toContain("user-secret-id")
    })
  })

  describe("Consent-based hashing", () => {
    it("should only include hashed user ID when explicit consent given", () => {
      const inputWithConsent: FeedbackInput = {
        ruleId: "rule-123",
        sentiment: Sentiment.POSITIVE,
        appVersion: "1.0.0",
        userId: "user-123",
        hasConsent: true,
      }

      const inputWithoutConsent: FeedbackInput = {
        ...inputWithConsent,
        hasConsent: false,
      }

      const recordWithConsent = createFeedbackRecord(inputWithConsent)
      const recordWithoutConsent = createFeedbackRecord(inputWithoutConsent)

      expect(recordWithConsent.anonymousUserHash).toBeDefined()
      expect(recordWithoutConsent.anonymousUserHash).toBeUndefined()
    })

    it("should use one-way hash that cannot be reversed", () => {
      const input: FeedbackInput = {
        ruleId: "rule-123",
        sentiment: Sentiment.POSITIVE,
        appVersion: "1.0.0",
        userId: "user-123",
        hasConsent: true,
      }

      const record = createFeedbackRecord(input)

      // Hash should not contain original userId
      expect(record.anonymousUserHash).not.toContain("user-123")
      // Hash should be SHA-256 format
      expect(record.anonymousUserHash).toMatch(/^[a-f0-9]{64}$/)
    })
  })
})

describe("Feedback correlation scenarios", () => {
  // These tests document how feedback correlates to rules

  describe("Rule feedback correlation", () => {
    it("should track feedback for a specific rule", () => {
      const feedbackForRule: FeedbackRecord[] = [
        {
          ruleId: "rule-vat-standard",
          sentiment: "positive",
          appVersion: "1.0.0",
          createdAt: new Date("2024-01-01"),
        },
        {
          ruleId: "rule-vat-standard",
          sentiment: "positive",
          appVersion: "1.0.0",
          createdAt: new Date("2024-01-02"),
        },
        {
          ruleId: "rule-vat-standard",
          sentiment: "negative",
          appVersion: "1.0.0",
          reasonCode: "inaccurate",
          createdAt: new Date("2024-01-03"),
        },
      ]

      // Calculate stats for this rule
      const positiveCount = feedbackForRule.filter((f) => f.sentiment === "positive").length
      const negativeCount = feedbackForRule.filter((f) => f.sentiment === "negative").length
      const percentage = calculateNegativeFeedbackPercentage({
        positive: positiveCount,
        negative: negativeCount,
      })

      expect(percentage).toBeCloseTo(0.333, 2) // ~33% negative
    })
  })

  describe("Reason code analysis", () => {
    it("should allow filtering by reason code for targeted improvements", () => {
      const feedbackRecords: FeedbackRecord[] = [
        {
          ruleId: "rule-1",
          sentiment: "negative",
          appVersion: "1.0.0",
          reasonCode: "inaccurate",
          createdAt: new Date(),
        },
        {
          ruleId: "rule-1",
          sentiment: "negative",
          appVersion: "1.0.0",
          reasonCode: "outdated",
          createdAt: new Date(),
        },
        {
          ruleId: "rule-1",
          sentiment: "negative",
          appVersion: "1.0.0",
          reasonCode: "inaccurate",
          createdAt: new Date(),
        },
      ]

      const inaccurateCount = feedbackRecords.filter((f) => f.reasonCode === "inaccurate").length
      const outdatedCount = feedbackRecords.filter((f) => f.reasonCode === "outdated").length

      expect(inaccurateCount).toBe(2)
      expect(outdatedCount).toBe(1)
    })
  })
})

describe("Review queue scenarios", () => {
  it("should flag rules with >30% negative feedback for review", () => {
    const ruleStats: RuleWithNegativeFeedback[] = [
      { ruleId: "rule-good", negativePercent: 0.1, totalFeedback: 50 },
      { ruleId: "rule-bad", negativePercent: 0.4, totalFeedback: 100 },
      { ruleId: "rule-terrible", negativePercent: 0.6, totalFeedback: 30 },
    ]

    const needsReview = filterRulesWithHighNegativeFeedback(ruleStats)

    expect(needsReview).toHaveLength(2)
    expect(needsReview.map((r) => r.ruleId)).toContain("rule-bad")
    expect(needsReview.map((r) => r.ruleId)).toContain("rule-terrible")
    expect(needsReview.map((r) => r.ruleId)).not.toContain("rule-good")
  })

  it("should prioritize rules with highest negative feedback", () => {
    const ruleStats: RuleWithNegativeFeedback[] = [
      { ruleId: "rule-medium", negativePercent: 0.35, totalFeedback: 100 },
      { ruleId: "rule-worst", negativePercent: 0.7, totalFeedback: 50 },
      { ruleId: "rule-bad", negativePercent: 0.45, totalFeedback: 80 },
    ]

    const needsReview = filterRulesWithHighNegativeFeedback(ruleStats)

    // Should be sorted by negativePercent descending
    expect(needsReview[0].ruleId).toBe("rule-worst")
    expect(needsReview[1].ruleId).toBe("rule-bad")
    expect(needsReview[2].ruleId).toBe("rule-medium")
  })
})
